## 构造函数模式
缺点：每个方法都要在每个实例上重新创造一遍，每个方法是不同的Function的实例,每定义一个函数就是实例化一个对象。函数是对象
以这种方式创建函数，会导致不同的作用域链和标识符解析。*** 不同实例上的同名函数是不相等的 ***
构造函数首字母大写
属性和方法在构造函数里
```
function Person(name,age,job){
	this.name = name,
	this.age = age,
	this.job = job,
	this.setName = function(){
		console.log(this.name)
	}
}
var newPerson = new Person('N',18,'jobc');
var newPerson1 = new Person('A',18,'jobc');
newPerson.setName == newPerson1.setName     // false,
new 操作：
1、创建一个新对象；
2、将构造函数的作用域赋给新对象(this)；
3、执行构造函数中的代码(为新对象添加属性);
4、返回新对象；
newPerson.constructor => Person
newPerson instanceof Object //true
newPerson instanceof Person //true

```

## 原型模式(prototype)
缺点：
1、忽略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取到相同的属性
2、共享                    *** 不同实例上的同名函数是相等的 ***
属性和方法在原型prototype里 
实例和构造函数(空函数) 的关系  new出来的实例而已
实例和构造函数原型的对象----->实例.__proto__   访问原型对象
实例的指针只指向原型，并非指向构造函数
```
//默认给原型添加属性和方法写法，不重写原型
A.prototype.x = x;

function A(){} //构造函数
//A的原型增加属性和方法,并重写原型方法😭。有一个新的原型new A.prototype
* var s = new A() 如果实例写在这里 ,原型方法重写后，实例的指针指向旧的原型 A.prototype
A.prototype = {
	constructor:A,  //指明构造函数 , 没有这个代码  ,那么A.prototype.constructor是Object
	x:x
}
* var b = new A() 正确的写法
* 调用s.x获取不到属性和方法
* 可以获取到b.x属性和方法
```
* 原型里的属性和方法是共享的
* 实例可以私有自己的属性和方法(如果没有会去实例里找)
------------------------------------------------------------
只要创建新函数,就会根据一组特定的规则为该函数创建一个prototype属性,
这个属性指向函数的原型对象
------------------------------------------------------------
默认情况：所有原型对象会获得constructor(构造函数)属性,
这个属性指向prototype属性所在函数的指针(构造函数)。
构造函数.prototy.constructor === 构造函数  // true
------------------------------------------------------------
验证:实例和原型的关系
构造函数.prototype.isPrototypeOf(实例)  // true | false
Object.getPrototypeOf(实例)           //获取到原型对象
------------------------------------------------------------
验证:属性和方法是实例自有还是原型的
实例.hasOwnProperty(属性或方法)       // true:自有 | false:原型
```
function hasPrototypeProperty(obj,name){
	//属性是否在原型中
	//obj.hasOwnProperty(name)  实例自有
	//in 操作符  属性在obj有没有
	return !obj.hasOwnProperty(name) && name in obj;
}
```
------------------------------------------------------------
枚举:原型属性和方法
Object.getOwnPerprotyNames(构造函数.prototype)
```
每个函数都有一个prototype原型属性
将共有的属性和方法放到原型对象中

```
# 构造函数 + 原型
构造函数：用于定义实例属性
原型：定义方法和共享属性
结果：每个实例都有自己的一份实例属性的副本，但同时又共享着方法的引用；
混合模式支持向构造函数传递参数；
最大限度的节省内存；
//构造函数
function Person(name,age,job){
	this.name=name;
	this.age=age;
	this.fr = ['a','b'];
}
//原型
Person.prototype = {
	constructor:Person,
	sName:function(){alert(this.name)}
}
var Person1 = new Person('N','18');
var Person2 = new Person('S','18');
Person1.fr.push('C');
Person1.fr
Person2.fr
Person1.fr == Person2.fr
Person1.sName == Person2.sName
//共同合作时，防止别人在原型添加相同的函数
if(typeof this.sName != 'function'){
	Person.prototype.sName=function(){}
}
** 函数的参数是按值传递的 **
保存对象的变量，它里面装的值是这个对象在堆内存中的地址
按值传递的意思就是形参是实参的复制;
如果按引用传递：函数的形参接收实参的隐式引用，而不再是副本。这意味着函数形参的值如果被修改，实参也会被修改。同时两者指向相同的值
** 直接改变形参本身，比如重新给形参分配一块内存，那么此时形参的改变就影响不到实参。所以复杂数据类型在传递时也并不是按照引用传递的 **
主要是在地址上
```
var Person = function(obj){
	obj.name='ccc';
	obj = new Object();
	obj.name='vvv';
	return obj.name;
}
var s = {name:'aaa'}
var a = Person(s);
console.log(s.name+' | '+a)
```
** 闭包中的this是在闭包创建的时候就指定好了，并不是在调用的时候指定 **

var name = 'the window';
var obj = {
	name:'My Object',
	getName:function(){
		return this.name;
	}
}
obj.getName()      //My Object
(obj.getName)()    //My Object
(obj.getName = obj.getName)()  // the window   
//先执行赋值语句，然后调用赋值后的结果，因为表达式的值是函数本身。所以this是window

什么是闭包？
内部函数访问外部函数作用域的变量

私有变量：函数的参数、局部变量、在函数内部定义的其他函数
闭包中存在HTML元素，那么元素无法销毁
解决：释放-->元素=nunll

==================================================================================== 
Regexp:

### 字符类别
```
.:
1)匹配任意单个字符，但是行结束符除外：\n \r \u2028 或 \u2029
2)/.y/ 匹配 "yes make my day" 中的 "my" 和 "ay"，但是不匹配 "yes"

\d:   \D:[^0-9]
匹配任意阿拉伯数字。等价于[0-9]

\w:   \W:[^A-Za-z0-9_]
匹配任意来自基本拉丁字母表中的字母、数字、下划线。等价于 [A-Za-z0-9_]

\s:   \S:匹配一个非空白符
匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格

\n:
匹配一个换行符
\r:匹配一个回车符
\t:匹配一个水平制表符
\v:匹配一个垂直制表符
\f:匹配一个换页符
[\b]:匹配一个退格符（不要与 \b 混淆）
```
### 边界
```
^:
1)匹配输入开始.
2)/^A/ 不匹配 "an A" 中的 "A"，但匹配 "An A" 中的 "A"

$:
1)匹配输入结尾.
2)/t$/ 不匹配 "eater" 中的 "t"，但匹配 "eat" 中的 "t"

\b:
1)匹配一个零宽单词边界,如一个字母与一个空格之间
2)/\bno/ 匹配 "at noon" 中的 "no"，/ly\b/ 匹配 "possibly yesterday." 中的 "ly"
```
### 分组与反向引用
```
(x):
匹配 x 并且捕获匹配项。 这被称为捕获括号
/(foo)/ 匹配且捕获 "foo bar." 中的 "foo"。被匹配的子字符串可以在结果数组的元素 [1], ..., [n] 中找到，或在被定义的 RegExp 对象的属性 $1, ..., $9 中找到

\n:
n 是一个正整数。一个反向引用,指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串
/apple(,)\sorange\1/ 匹配 "apple, orange, cherry, peach." 中的 "apple,orange,"

(?:x):匹配 x 不会捕获匹配项
```
### 数量词
```
如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化

x*：
1)匹配前面的模式 x 0或多次
2)匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于o{0,}
x+：
1)匹配前面的模式 x 1 或多次。等价于 {1,}
2)匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。
x?:
1)匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}
x*? x+?:
像上面的 * 和 + 一样匹配前面的模式 x，然而匹配是最小可能匹配
/".*?"/ 匹配 '"foo" "bar"' 中的 '"foo"'，而 * 后面没有 ? 时匹配 '"foo" "bar"'
x?:
匹配前面的模式 x 0 或 1 次,/e?le?/ 匹配 "angel" 中的 "el"，"angle" 中的 "le"
x(?=y):
只有当 x 后面紧跟着 y 时，才匹配 x。 例如，/Jack(?=Sprat)/ 只有在 'Jack' 后面紧跟着 'Sprat' 时，才会匹配它。/Jack(?=Sprat|Frost)/ 只有在 'Jack' 后面紧跟着 'Sprat' 或 'Frost' 时，才会匹配它。然而，'Sprat' 或 'Frost' 都不是匹配结果的一部分
x(?!y):
只有当 x 后面不是紧跟着 y 时，才匹配 x。例如，/\d+(?!\.)/ 只有当一个数字后面没有紧跟着一个小数点时，才会匹配该数字。/\d+(?!\.)/.exec("3.141") 匹配 141 而不是 3.141

断言:
x(?=y):仅匹配被y跟随的x,举个例子，/Jack(?=Sprat)/，如果"Jack"后面跟着sprat，则匹配之。
/Jack(?=Sprat|Frost)/ ，如果"Jack"后面跟着"Sprat"或者"Frost"，则匹配之。但是，"Sprat" 和"Frost" 都不会在匹配结果中出现
x(?!y):仅匹配不被y跟随的x。举个例子，/\d+(?!\.)/ 只会匹配不被点（.）跟随的数字。
/\d+(?!\.)/.exec('3.141') 匹配"141"，而不是"3.141"
```
------------------------------------------
```
experience:
^abc$ :要求以abc开头和以abc结尾的字符串，实际上是只有abc匹配

{0,}、{1,}、{0,1}一个字符可以出现的次数或者顺序
  *、  +、   ?
ab*=ab{0,}:匹配以a开头,后面可以接0个或者N个b组成的字符串("a", "ab", "abbb", 等)匹配a后面0个或n个b
ab+=ab{1,}:匹配以ab开头,后面可以接1个或者N个b组成的字符串("ab", "abbb",等)匹配ab后面1个或n个b
ab?=ab{0,1}:匹配以ab开头,后面可以接0个或者1个b
a?b+$:匹配一个或者0个a，一个以上b结尾的字符串
要点: '*', '+',和 '?'只管它前面那个字符

ab{2}:要求a后面一定要跟两个b(一个也不能少)("abb");
ab{2,}:要求a后面一定要有两个或者两个以上b(如"abb", "abbbb", 等.);
ab{3,5}:要求a后面可以有2-5个b("abbb", "abbbb", or "abbbbb");
a(bc)*:匹配a后面0个或1个bc
a(bc){1,5}:匹配a后面1-5个bc
|：或
(b|cd)ef:匹配bed或cdef
一个点('.')可以代表所有的单一字符,不包括"\n"
匹配\n:'[\n.]
^.{3}$:匹配三个字符结尾
中括号括住的内容只匹配一个单一的字符
[ab]匹配单个a或b(a|b一样)
[a-z]匹配a-z任意一个字符
[0-9]%匹配含有形如x%
^用在中括号开头的时候,就表示排除括号里的字符

\b匹配单词边界：比如've\b',可以匹配love里的ve而不匹配very里有ve
```
---------------------------------------------------------
```
function:
/Regexp/g.exec(str):指定字符串中执行一个搜索匹配。返回一个结果数组或 null
不但可以到得被匹配的字符串的值及其索引，还可以得到每个子分组的匹配结果
Regexp.test(str):根据给定的源字符串是否能匹配正则表达式而返回true或false
str.search(Regexp):传入一个正则表达式,执行后返回第一个匹配的索引，或-1
str.match(Regexp):
1)当我们传入全局匹配的g标签时，match方法会返回包含所有该正则匹配的字符串的数组而不会包含任何子分组的匹配
2)当我们未传入全局匹配的g标签时，match方法会返回一个包含一个该正则完整匹配的字符及其后仍次的子分组匹配字符的数组
3)当正则表达式没有发现匹配, match会返回 null ,而不是空数组
str.replace(Regexp,function($0,$1,$2){return $1})
```
